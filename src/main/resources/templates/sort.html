<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>排序详情</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
    <link rel="stylesheet" href="./css/typo.css">
    <link rel="stylesheet" href="./lib/prism/prism.css">
    <link rel="stylesheet" href="./lib/tocbot/tocbot.css">
    <link rel="stylesheet" href="./css/me.css">
    <style>
        li {
            list-style-type: none;
        }

        p {
            text-indent: 2em;
        }

        li a {
            width: 90% !important;
        }
    </style>
</head>
<body>
<!--导航-->
<nav class="ui inverted attached segment m-padded-tb-mini m-shadow-small"
     style="width: 18%;height: 100vh;float: left;position: fixed">
    <div class="ui container">
        <!--为了适应手机端查看页面，添加stackable属性，代表可堆叠，给grid之前加上stackable-->
        <div class="ui inverted secondary stackable menu">
            <ul>
                <li>
                    <h2 class="ui teal header item" style="color: #7F007F !important;">嵌入式数据结构</h2>
                </li>
                <li>
                    <a href="array.html" class="m-item item m-mobile-hide"> 数组</a>
                </li>
                <li>
                    <a href="stack and queue.html" class="m-item item m-mobile-hide"> 栈和队列</a>
                </li>
                <li>
                    <a href="Linear and linked lists.html" class="m-item item m-mobile-hide"> 线性表和链表</a>
                </li>

                <li>
                    <a href="tree.html" class="m-item item m-mobile-hide"> 树</a>
                </li>
                <li>
                    <a href="graph.html" class="m-item item m-mobile-hide"> 图</a>
                </li>
                <li>
                    <a href="sort.html" class="active m-item item m-mobile-hide"> 排序</a>
                </li>
                <li>
                    <div class="right m-item item m-mobile-hide">
                        <!-- transparent搜索框显示为透明 inverted颜色反转 -->
                        <div class="ui icon inverted transparent input">
                            <input type="text" placeholder="Search....">
                            <i class="search link icon"></i>
                        </div>
                    </div>
                </li>
            </ul>
        </div>
    </div>
    <!-- 点击再显示，加一个图标  menu toggle只是为了使用，另一种方法也可以用id  -->
    <a href="#" class="ui menu toggle black icon button m-right-top m-mobile-show">
        <i class="sidebar icon"></i>
    </a>
</nav>
<!--中间内容-->

<div class="m-container-small m-padded-tb-big" style="width: 82%;float: left;margin-left: 18% !important">
    <div class="ui container">
        <div class="ui top attached segment">
            <!--头部-->
            <div class="ui  horizontal link list">
                <div class="item">
                    <img src="./images/small.jpg" alt="" class="ui avatar image">
                    <div class="content"><a href="#" class="header">王晶</a></div>
                </div>
                <div class="item">
                    <i class="calendar icon"></i>2020-08-15
                </div>
                <div class="item">
                    <i class="eye icon"></i>666
                </div>
            </div>
        </div>
        <div class="ui  attached segment">
            <!--图片区域-->
            <img src="./images/sort1.png" alt="" class="ui fluid rounded image">
        </div>
        <div class="ui attached padded segment">
            <!--内容部分-->
            <div class="ui right aligned basic segment">
                <div class="ui orange basic label" style="width: 77px;height: 49px;font-size: 20px;">原创</div>
            </div>
            <h2 class="ui center aligned header">排序</h2>
            <br>
            <div id="content" class="typo typo-selection js-toc-content  m-padded-lr-responsive m-padded-tb-large">
                <h2>一、排序的定义和分类</h2>
                <h4><strong>1.排序的定义</strong></h4>
                <p>将杂乱无章的数据元素，通过一定的方法按关键字顺序排列的过程叫做排序。</p>
                <h4><strong>2.排序的分类</strong></h4>
                <p>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p>
                <p>线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</p>
                <p><a href="http://html5doctor.com/u-element/">排序示例:</a></p>
                <img src="./images/sort2.png" alt="" class="ui rounded image">
                <p></p>
                <h4><strong>3.排序的比较</strong></h4>
                <p><a href="http://html5doctor.com/u-element/">排序算法比较示例:</a></p>
                <img src="./images/sort3.png" alt="" class="ui rounded image">
                <p></p>
                <h5>说明：</h5>
                <p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</p>
                <p>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
                <p>内排序：所有排序操作都在内存中完成；</p>
                <p>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
                <h2>二、各算法原理及实现</h2>
                <h4><strong>1.冒泡排序（Bubble Sort）</strong></h4>
                <p>基本思想：两个数比较大小，较大的数下沉，较小的数冒起来。</p>
                <p>算法描述：
                <ol>
                    <li>1) 比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
                    <li>2) 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
                    <li>3) 针对所有的元素重复以上的步骤，除了最后一个；</li>
                    <li>4) 重复步骤1~3，直到排序完成。</li>
                </ol>
                </p>
                <p><a href="http://html5doctor.com/u-element/">动图演示示例:</a></p>
                <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif"
                     alt="" class="ui rounded image">
                <p></p>
                <h4><strong>2.选择排序（Selection Sort）</strong></h4>
                <p>基本思想：选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
                    然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
                <p>算法描述：（n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。）
                <ol>
                    <li>1) 初始状态：无序区为R[1..n]，有序区为空；</li>
                    <li>2) 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，
                        将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
                    </li>
                    <li>3) n-1趟结束，数组有序化了。</li>
                </ol>
                </p>
                <p><a href="http://html5doctor.com/u-element/">动图演示示例:</a></p>
                <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif"
                     alt="" class="ui rounded image">
                <p></p>
                <h4><strong>3.插入排序（Insertion Sort）</strong></h4>
                <p>基本思想：在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p>
                <p>算法描述：
                <ol>
                    <li>1) 从第一个元素开始，该元素可以认为已经被排序；</li>
                    <li>2) 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
                    <li>3) 如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
                    <li>4) 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
                    <li>将新元素插入到该位置后；</li>
                    <li>重复步骤2~5。</li>
                </ol>
                </p>
                <p><a href="http://html5doctor.com/u-element/">动图演示示例:</a></p>
                <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif"
                     alt="" class="ui rounded image">
                <p></p>
                <h4><strong>4.希尔排序（Shell Sort）</strong></h4>
                <p>基本思想：希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。
                    它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p>
                <p>算法描述：
                <ol>
                    <li>1) 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；</li>
                    <li>2) 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；</li>
                    <li>3) 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。
                        仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
                    </li>
                </ol>
                </p>
                <p><a href="http://html5doctor.com/u-element/">动图演示示例:</a></p>
                <img src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif"
                     alt="" class="ui rounded image">
                <p></p>
                <h4><strong>5.归并排序（Merge Sort）</strong></h4>
                <p>基本思想：归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
                    将已有序的子序列合并，得到完全有序的序列；
                    即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
                <p>算法描述：
                <ol>
                    <li>1) 把长度为n的输入序列分成两个长度为n/2的子序列；</li>
                    <li>2) 对这两个子序列分别采用归并排序；</li>
                    <li>3) 将两个排序好的子序列合并成一个最终的排序序列。</li>
                </ol>
                </p>
                <p><a href="http://html5doctor.com/u-element/">动图演示示例:</a></p>
                <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif"
                     alt="" class="ui rounded image">
                <p></p>
                <h4><strong>6.快速排序（Quick Sort）</strong></h4>
                <p>基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，
                    则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
                <p>算法描述：
                <ol>
                    <li>1) 从数列中挑出一个元素，称为 “基准”（pivot）；</li>
                    <li>2) 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。
                        在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
                    </li>
                    <li>3) 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
                </ol>
                </p>
                <p><a href="http://html5doctor.com/u-element/">动图演示示例:</a></p>
                <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif"
                     alt="" class="ui rounded image">
                <p></p>
                <h4><strong>7.堆排序（Heap Sort）</strong></h4>
                <p>基本思想：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，
                    并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
                <p>算法描述：
                <ol>
                    <li>1) 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
                    <li>2) 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；</li>
                    <li>3) 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，
                        得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。
                    </li>
                </ol>
                </p>
                <p><a href="http://html5doctor.com/u-element/">动图演示示例:</a></p>
                <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif"
                     alt="" class="ui rounded image">
                <p></p>
                <h4><strong>8.计数排序（Counting Sort）</strong></h4>
                <p>基本思想：计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
                <p>算法描述：
                <ol>
                    <li>1) 找出待排序的数组中最大和最小的元素；</li>
                    <li>2) 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
                    <li>3) 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
                    <li>4) 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
                </ol>
                </p>
                <p><a href="http://html5doctor.com/u-element/">动图演示示例:</a></p>
                <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif" alt=""
                     class="ui rounded image">
                <p></p>
                <h4><strong>9.桶排序（Bucket Sort）</strong></h4>
                <p>基本思想：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
                    桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，
                    将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
                <p>算法描述：
                <ol>
                    <li>1) 设置一个定量的数组当作空桶；</li>
                    <li>2) 遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
                    <li>3) 对每个不是空的桶进行排序；</li>
                    <li>4) 从不是空的桶里把排好序的数据拼接起来。</li>
                </ol>
                </p>
                <p><a href="http://html5doctor.com/u-element/">动图演示示例:</a></p>
                <img src="./images/sort4.png" alt="" class="ui rounded image">
                <h4><strong>10.基数排序（Radix Sort）</strong></h4>
                <p>基本思想：基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。
                    有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
                <p>算法描述：
                <ol>
                    <li>1) 取得数组中的最大数，并取得位数；</li>
                    <li>2) arr为原始数组，从最低位开始取每个位组成radix数组；</li>
                    <li>3) 对radix进行计数排序（利用计数排序适用于小范围数的特点）。</li>
                </ol>
                </p>
                <p><a href="http://html5doctor.com/u-element/">动图演示示例:</a></p>
                <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232453668-1397662527.gif"
                     alt="" class="ui rounded image">
                <p></p>


            </div>
            <div class="ui attached positive message ">
                <!--博客信息说明-->
                <div class="ui middle aligned grid">
                    <div class="eleven wide column">
                        <ui class=" list">
                            <li>文档作者：王晶</li>
                            <li>发表时间：2020-08-15</li>
                            <!-- <li>版权声明：不可转载-非商用-非衍生-保持署名</li> -->
                            <li>文档转载：请添加右侧作者微信二维码</li>
                        </ui>
                    </div>
                    <div class="five wide column">
                        <img src="./images/wechat.jpg" alt="" class="ui right floated rounded bordered image"
                             style="width: 110px">
                    </div>
                </div>
            </div>
            <div id="comment-container" class="ui bottom attached segment">
                <!--留言区域列表-->
                <!-- <div class="ui teal segment">
                  <div class="ui comments">
                    <h3 class="ui dividing header"><trans oldtip="Comments" newtip="评论意见">Comments</trans></h3>
                      <div class="comment">
                        <a class="avatar">
                        <img src="https://picsum.photos/id/1001/200/200">
                        </a>
                     <div class="content">
                     <a class="author"><trans oldtip="Matt" newtip="马特">Matt</trans></a>
                    <div class="metadata">
                      <span class="date"><trans oldtip="Today at 5:42PM" newtip="今天下午5：42">Today at 5:42PM</trans></span>
                    </div>
                    <div class="text"><trans oldtip=" How artistic! " newtip="多么艺术啊！"> How artistic! </trans></div>
                    <div class="actions">
                    <a class="reply">回复</a>
                  </div>
                 </div>
                     </div>
                 <div class="comment">
                  <a class="avatar">
                    <img src="https://picsum.photos/id/1002/200/200">
                  </a>
                 <div class="content">
                   <a class="author"><trans oldtip="Elliot Fu" newtip="艾略特">Elliot Fu</trans></a>
                   <div class="metadata">
                     <span class="date"><trans oldtip="Yesterday at 12:30AM" newtip="昨天中午12：30">Yesterday at 12:30AM</trans></span>
                   </div> -->
                <!-- <div class="text">
                  <p><trans oldtip="This has been very useful for my research. Thanks as well!" newtip="这对我的研究非常有用。也谢谢你！">This has been very useful for my research. Thanks as well!</trans></p>
                </div> -->
                <!-- <div class="actions">
                  <a class="reply">回复</a>
                </div> -->
            </div>
            <!-- <div class="comments">
              <div class="comment">
                <a class="avatar">
                  <img src="https://picsum.photos/id/1003/200/200">
                </a>
                <div class="content">
                  <a class="author"><trans oldtip="Jenny Hess" newtip="珍妮·赫斯">Jenny Hess</trans></a>
                  <div class="metadata">
                    <span class="date"><trans oldtip="Just now" newtip="刚才">Just now</trans></span>
                  </div>
                  <div class="text"><trans oldtip=" Elliot you are always so right :) " newtip="埃利奥特，你总是那么正确：)"> Elliot you are always so right :) </trans></div>
                  <div class="actions">
                    <a class="reply">回复</a>
                  </div>
                </div>
              </div> -->
        </div>
    </div>
    <!-- <div class="comment">
      <a class="avatar">
        <img src="https://picsum.photos/id/1004/200/200">
      </a>
      <div class="content">
        <a class="author"><trans oldtip="Joe Henderson" newtip="乔·亨德森">Joe Henderson</trans></a>
        <div class="metadata">
          <span class="date"><trans oldtip="5 days ago" newtip="5天前">5 days ago</trans></span>
        </div>
        <div class="text"><trans oldtip=" Dude, this is awesome. Thanks so much " newtip="伙计，这太棒了。非常感谢"> Dude, this is awesome. Thanks so much </trans></div>
         <div class="actions">
          <a class="reply">回复</a>
        </div> -->
</div>
-->
<div class="m-padded m-fixed m-right-bottom ">
    <div class="ui vertical icon buttons ">
        <!--     <button type="button" class="ui toc teal button">目录</button>-->
        <a href="#comment-container" class="ui teal button">作者</a>
        <!--     <button type="button" class="ui wechat icon button"><i class="weixin icon"></i> </button>-->


        <a href="#" class="ui icon button"><i class="chevron up icon"></i></a>
        <!--直接返回顶部修改为平滑滚动到顶部-->
        <!--<div id="toTop-button" class="ui icon button"><i class="chevron up icon"></i> </div>-->
    </div>
    <!--生成二维码  将已经写死的二维码注释掉，既可以随机生成二维码-->
    <div id="qrcode" class="ui wechat-qr flowing popup transition hidden " style="width: 130px !important;">
        <!--
          <div id="qrcode" class="ui wechat-qr flowing popup transition hidden m-padded-mini" style="width: 130px !important;">
          <img src="images/wechat.jpg" alt="" class="ui rounded image "  style="width:120px !important;">
        -->
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.2/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
<!--<script src="//cdn.jsdelivr.net/npm/jquery.scrollto@2.1.2/jquery.scrollTo.min.js"></script>-->

<script src="..//static/lib/prism/prism.js"></script>
<script src="..//static/lib/tocbot/tocbot.min.js"></script>
<script src="..//static/lib/qrcode/qrcode.min.js"></script>
</body>
</html>